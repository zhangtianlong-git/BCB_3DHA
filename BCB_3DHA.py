import math
import explore_coordinates_calculation as ecc
import matplotlib.pyplot as plt
import numpy as np
import heapq
from get_explore_cost_and_carbon import OTHER_COST_CARBON, get_cost_and_tunnel_info
import time
from Input_paramters import start_angle, ZRESO, THETA_XY_RESOLUTION, GRADIENT_Z_RESOLUTION, z_s, z_g, x_g, x_s, y_g, y_s, second_res, zres_in_astar, terrain, RADIUS, GRADIENTS, MIN_LEN_SLOPE, MIN_LEN_CURV, MIN_LEN_TAN, K_MIN, MAX_LEN_TAN, MAX_NEAR_GRADIENT, EXPLORE_RES, LEN_SPIRAL
from merge_heuristic_cost_and_carbon import H_COST_CARBON, X_NEW_ORIGIN, Y_NEW_ORIGIN
from GIS_DATA.House_table import house_info_dict
import general_tool_functions as gtf

global time1, time2, time3
time1, time2, time3 = 0, 0, 0
[house_unit_cost, house_unit_carbon] = OTHER_COST_CARBON["house_cost_carbon"] 

class Node:
    def __init__(self, xlist,ylist,zlist,theta_xy_list,
        gradient_z_list=0,pind=None,cost=0,line_type=None,radius=None,seqZ=0,seqY=0,seqS=0,lens=0,
        start=False,seqSS=0,pre_ver_cur_len=0,seq_tunnul=0,seq_bri=0,high_bri=0, carbon=0, structure_type=None,
        earthwork=0, water=0, total_house=0, house_set=set(), f_cost=0, f_carbon=0):
        self.xlist = xlist  # The x-coordinate is a list
        self.ylist = ylist
        self.zlist = zlist
        self.theta_xy_list = theta_xy_list
        self.gradient_z_list = gradient_z_list
        self.pind = pind  # Pointer to the previous exploration node (parent node)
        self.cost = cost  # Total cost
        self.radius = radius  # Radius of the current exploration node
        self.lens = lens  # Total alignment length from the current node to the starting point (in the horizontal direction)
        self.line_type = line_type  # 'Z' represents a straight line, 'Y' represents a circle, and 'ZH' and 'HZ' represent transition curves
        self.seqZ = seqZ  # Length of the continuous straight line segment
        self.seqY = seqY  # Length of the continuous circular curve
        self.seqS = seqS  # Length of the continuous slope
        self.seqSS = seqSS  # Length of the continuous slope, but it will be reset by the transition curve
        self.start = start  # Whether it is the starting point; the starting point undergoes special handling
        self.pre_ver_cur_len = pre_ver_cur_len  # Half of the length of the previous vertical curve
        self.seq_tunnul = seq_tunnul  # Length of the continuous tunnel
        self.seq_bri = seq_bri  # Length of the continuous bridge
        self.high_bri = high_bri  # Length of the continuous high bridge
        self.carbon = carbon  # carbon
        self.structure_type = structure_type  # "T" for tunnel, "S" for subgrade, and "B" for bridge.
        self.earthwork = earthwork
        self.water = water
        self.total_house = total_house
        self.house_set = house_set
        self.f_cost = f_cost  # Actual cost plus heuristic cost
        self.f_carbon = f_carbon  # Actual carbon plus heuristic carbon
        self.get_pre_constrain_inf()  # Determine which geometric constraints have been satisfied, in order to determine the next exploration approach
        # potential explorations, [[Line type, radius, whether there is a change in alignment, slope, whether there is a change in slope, whether reset by transition curve], ...]
        self.pe = self.get_pe()

    # Constraints before the current node; due to the consideration of vertical curves, the constraints after the current node must also be taken into account
    def get_pre_constrain_inf(self):
        # Continuous slope length constraint
        self.enough_pre_slope_len_vertical = self.seqS >= (
            MIN_LEN_SLOPE + self.pre_ver_cur_len
        )
        # Consider the constraint that horizontal and vertical transition curves do not overlap. Since SeqSS ≤ seqS, only one seqSS needs to be checked here
        self.enough_pre_slope_len_horizontal = self.seqS >= self.pre_ver_cur_len
        # Horizontal straight line length constraint
        self.enough_tangent_len = self.seqZ >= MIN_LEN_TAN
        # Horizontal curve length constraint
        self.enough_curve_len = self.seqY >= MIN_LEN_CURV

    # To account for vertical curves, consider the constraints after the current node
    def get_next_constrain_inf(self, g_old, g_new):
        # Determine the current slope length after the next slope change based on the slope gradient, which needs to be combined with the previous slope length to define the final straight line length constraint
        next_ver_cur_len = abs(K_MIN * (g_old - g_new)) / 2
        # Overall slope length constraint
        self.enough_next_slope_len_vertical = self.seqS >= (
            MIN_LEN_SLOPE + self.pre_ver_cur_len + next_ver_cur_len
        )
        # Prevent the slope length generated by the new slope gradient from overlapping with the transition curve
        self.enough_next_slope_len_horizontal = self.seqSS >= next_ver_cur_len

    def get_pe(self):
        lt = self.line_type
        pe = []  # potential explorations
        grd = self.gradient_z_list
        if lt == "Z":
            # [[Line type, radius, whether there is a change in alignment, slope, whether there is a change in slope, whether reset by transition curve], ...]
            if self.seqZ <= MAX_LEN_TAN:
                pe.append(["Z", None, False, grd, False, False])
            # Change the slope on the straight segment, ensuring the slope length requirement is met and that the vertical transition curve does not overlap
            if (self.enough_pre_slope_len_vertical) or (self.start):
                for j in GRADIENTS:
                    if abs(grd - j) > MAX_NEAR_GRADIENT:
                        continue  # Maximum adjacent slope difference constraint
                    change_grd = not (grd == j)
                    if change_grd:
                        self.get_next_constrain_inf(grd, j)
                        if self.start or (
                            self.enough_next_slope_len_vertical
                            and self.enough_next_slope_len_horizontal
                        ):
                            pe.append(["Z", None, False, j, change_grd, False])
            # If the planar geometric constraints are satisfied, and the vertical transition curve does not overlap, a circular curve's transition curve can be added, but the slope gradient remains unchanged
            if (self.enough_tangent_len and self.enough_pre_slope_len_horizontal) or (
                self.start
            ):
                for i in RADIUS:
                    pe.append(["ZY", i, True, grd, False, False])
        elif lt == "Y":
            # Prevent the occurrence of reverse curves; the condition for this is that the deflection angle does not exceed π
            if (self.seqY) >= abs(self.radius) * 3.14:
                return pe
            # [[Line type, radius, whether there is a change in alignment, slope, whether there is a change in slope, whether reset by transition curve], ...]
            pe.append(["Y", self.radius, False, grd, False, False])
            # Change the slope on the circular curve, ensuring the slope length requirement is met and that the vertical transition curve does not overlap
            if self.enough_pre_slope_len_vertical:
                for j in GRADIENTS:
                    if abs(grd - j) > MAX_NEAR_GRADIENT:
                        continue  # Maximum adjacent slope difference constraint
                    change_grd = not (grd == j)
                    if change_grd:
                        self.get_next_constrain_inf(grd, j)
                        if (
                            self.enough_next_slope_len_vertical
                            and self.enough_next_slope_len_horizontal
                        ):
                            pe.append(["Y", self.radius, False, j, change_grd, False])
            # Building on the above, if the planar geometric constraints are met, a transition curve to a straight line can be added, but the slope gradient remains unchanged
            if self.enough_curve_len and self.enough_pre_slope_len_horizontal:
                pe.append(["YZ", self.radius, True, grd, False, False])
        elif lt == "ZY":
            pe.append(["Y", self.radius, True, grd, False, True])
        elif lt == "YZ":
            pe.append(["Z", None, True, grd, False, True])
        return pe


def get_neighbors(current):
    global time1, time2, time3
    pe = current.pe
    if pe:
        x_old, y_old, z_old = current.xlist, current.ylist, current.zlist
        theta_xy_old = current.theta_xy_list
        seq_tun_old, struc_t_old = current.seq_tunnul, current.structure_type
        high_bridge_old, seq_bri_old = current.high_bri, current.seq_bri

        not_in_start_area = (y_old < y_s-50)  # Determine whether it is near the starting point.
        seqZ, seqY = current.seqZ, current.seqY
        for i in pe:
            # [[Line type, radius, whether there is a change in alignment, slope, whether there is a change in slope, whether reset by transition curve], ...]
            t, r, c, g, gc, gs = i[0], i[1], i[2], i[3], i[4], i[5]
            if r and abs(r) < 30 and not_in_start_area:
                continue
            # Update the length of the continuous horizontal curve or straight line
            if t == "Z" or t == "Y":  # Calculate the coordinates of the next node
                arc_l = EXPLORE_RES  # Length of this exploration
                seqZ, seqY = 0, 0
                if t == "Z":
                    seqZ = EXPLORE_RES if c else current.seqZ + arc_l
                elif t == "Y":
                    seqY = EXPLORE_RES if c else current.seqY + arc_l
                x, y, z, theta_xy, gradient_z = ecc.z_y_move_list(x_old, y_old, z_old, theta_xy_old, g, r)
            elif t == "ZY":
                arc_l, seqZ, seqY = LEN_SPIRAL, 0, 0
                x, y, z, theta_xy, gradient_z = ecc.spr_move1_list(x_old, y_old, z_old, theta_xy_old, g, r)
            elif t == "YZ":
                arc_l, seqZ, seqY = LEN_SPIRAL, 0, 0
                x, y, z, theta_xy, gradient_z = ecc.spr_move2_list(x_old, y_old, z_old, theta_xy_old, g, r)
            else:
                raise

            # Update the length of the continuous slope segment and half of the previous slope length
            (seqS, pre_vc) = (
                (EXPLORE_RES, abs(K_MIN * (current.gradient_z_list - g)) / 2)
                if gc
                else (current.seqS + arc_l, current.pre_ver_cur_len)
            )
            # The slope length of the previous slope at the starting point is assumed to be 0
            pre_vc = 0 if current.start else pre_vc
            seqSS = EXPLORE_RES if (gc or gs) else current.seqSS + arc_l

            # Cost calculation
            xs_index, ys_index = x.astype(int), y.astype(int)
            zi = int(z[-1] // zres_in_astar)
            (ratio_xll, xi) = math.modf((x[-1]-X_NEW_ORIGIN)/second_res)
            (ratio_yll, yi) = math.modf((y[-1]-Y_NEW_ORIGIN)/second_res)
            cost_carbon_list = H_COST_CARBON.get((xi, yi, zi))
            if cost_carbon_list is None:
                continue
            h_cost, h_carbon = calc_heur_cost_carbon(cost_carbon_list, ratio_xll, ratio_yll)
            z_minus_t = z - terrain[xs_index, ys_index]
            house_list = []
            for tx, ty, tz in zip(xs_index, ys_index, z_minus_t):
                if tz > -15:  # Houses are only counted for non-tunnel sections
                    house_list += house_info_dict.get((tx, ty), [])
            house_set = set(house_list) - current.house_set
            house_area = sum(house_set)
            house_cost, house_carbon = house_unit_cost*house_area, house_unit_carbon*house_area

            out = get_cost_and_tunnel_info(z_minus_t, struc_t_old, seq_tun_old, seq_bri_old, high_bridge_old)

            if out is None:  # The maximum tunnel length does not meet the requirements
                continue
            [add_cost, add_carbon, struc_t_new, seq_tun_new, seq_bri_new, high_bri_new, earthwork_v, water_v] = out
            carbon = current.carbon + add_carbon + house_carbon
            cost = current.cost + add_cost + house_cost
            lens = current.lens + arc_l

            node = Node(
                x[-1],
                y[-1],
                z[-1],
                theta_xy,
                gradient_z,
                line_type=t,
                cost=cost,
                carbon=carbon,
                radius=r,
                pind=current,
                seqY=seqY,
                seqZ=seqZ,
                seqS=seqS,
                seqSS=seqSS,
                pre_ver_cur_len=pre_vc,
                lens=lens,
                seq_tunnul=seq_tun_new,
                seq_bri=seq_bri_new,
                high_bri=high_bri_new,
                structure_type=struc_t_new,
                earthwork=current.earthwork+earthwork_v,
                water=current.water+water_v,
                total_house=current.total_house+house_area,
                house_set=house_set,
                f_cost=cost+h_cost,
                f_carbon=carbon+h_carbon,
            )
            yield node


def calc_heur_cost_carbon(cost_carbon_list, ratio_xll, ratio_yll):   # Heuristic cost and carbon emissions are obtained through interpolation calculation
    ratio_xll_left, ratio_yll_left = 1 - ratio_xll, 1 - ratio_yll
    [cost_sll, carbon_sll, cost_sul, carbon_sul, cost_slu, carbon_slu] = cost_carbon_list
    h_cost = ((ratio_xll+ratio_yll)*cost_sll + ratio_xll_left*cost_sul + ratio_yll_left * cost_slu) * 0.5
    h_carbon = ((ratio_xll+ratio_yll)*carbon_sll + ratio_xll_left*carbon_sul + ratio_yll_left*carbon_slu) * 0.5
    return h_cost, h_carbon



def reback(current, show_fig=True):
    """Backtrack to the starting point to obtain detailed coordinate information"""
    tmp = current
    xs, ys, zs, ts = [], [], [], []
    bpd_lc, bpd_zs = [], []
    # Record intersection point information
    pi_x, pi_y, pi_r = [gx], [gy], [0]
    # Coordinates and angles stored for calculating intersection points
    p_old_x, p_old_y, p_old_angle = current.xlist, current.ylist, current.theta_xy_list
    while tmp.pind is not None:
        x_old, y_old, z_old = tmp.pind.xlist, tmp.pind.ylist, tmp.pind.zlist
        theta_xy_old = tmp.pind.theta_xy_list
        t, g, r = tmp.line_type, tmp.gradient_z_list, tmp.radius
        if tmp.gradient_z_list != tmp.pind.gradient_z_list:
            bpd_lc.append(tmp.pind.lens*30), bpd_zs.append(z_old)
        if t == "Z" or t == "Y":  # Calculate the coordinates of the next node
            x, y, z, _, _ = ecc.z_y_move_list(x_old, y_old, z_old, theta_xy_old, g, r)
        elif t == "ZY":
            x, y, z, _, _ = ecc.spr_move1_list(x_old, y_old, z_old, theta_xy_old, g, r)
            """Code has been added here to calculate the intersection point location and record the radius"""
            [x_t, y_t] = gtf.intersection(
                p_old_x, p_old_y, p_old_angle, x_old, y_old, theta_xy_old)
            pi_x.insert(0, x_t), pi_y.insert(0, y_t), pi_r.insert(0, r)
            p_old_x, p_old_y, p_old_angle = x_old, y_old, theta_xy_old
        elif t == "YZ":
            x, y, z, _, _ = ecc.spr_move2_list(x_old, y_old, z_old, theta_xy_old, g, r)
        xs_index, ys_index = x.astype(int), y.astype(int)
        ts = list(terrain[xs_index, ys_index]) + ts
        xs = list(x) + xs
        ys = list(y) + ys
        zs = list(z) + zs
        tmp = tmp.pind
    pi_x.insert(0, sx), pi_y.insert(0, sy), pi_r.insert(0, 0)
    bpd_lc.reverse(), bpd_zs.reverse()
    ss = [i*30 for i in range(len(xs))]
    """Endpoint connection section"""
    cx, cy = current.xlist, current.ylist
    dz = (bpd_zs[-1] - z_g)/current.seqS
    for i in range(current.seqS):  # Backtrack to update the elevation of the last slope
        zs[-(i+1)] = z_g + i*dz
    dx, dy, cl = (gx - cx)/dis_points, (gy - cy)/dis_points, current.lens*30
    (len_rest, len_ind) = math.modf(dis_points)
    for i in list(range(1, int(len_ind)+1))+[dis_points]:
        tx, ty = cx+i*dx, cy+i*dy
        tz = terrain[int(tx), int(ty)]
        xs.append(cx+i*dx), ys.append(cy+i*dy), ts.append(tz), ss.append(cl+i*30), zs.append(z_g)
    bpd_lc.append(cl), bpd_zs.append(z_g)  # The current exploration node is treated as a VPI
    bpd_lc.append(cl+dis_points*30), bpd_zs.append(z_g)  # Endpoint
    if show_fig:
        plt.figure(), plt.plot(xs, ys, "--g"), plt.plot(x_g, y_g, "*r"), plt.plot(x_s, y_s, "*r")
        plt.plot(pi_x, pi_y, '--y'), plt.plot(pi_x, pi_y, 'xr')
        plt.figure(), plt.plot(ss, zs, "--r"), plt.plot(ss, ts, "-k"), plt.plot(bpd_lc, bpd_zs, "^g"), plt.show()
    return [xs, ys, zs, ts, ss, bpd_lc, bpd_zs, pi_x, pi_y, pi_r]

# Main part
gx = x_g  # [m]
gy = y_g  # [m]
sx = x_s  # [m]
sy = y_s  # [m]
start = [sx, sy, z_s, ecc.pi_2_pi(np.deg2rad(start_angle))]
goal = [gx, gy, z_g, round(gy), ecc.pi_2_pi(np.deg2rad(0))]

nstart = Node(
    start[0],
    start[1],
    start[2],
    start[3],
    start=True,
    line_type="Z",
    structure_type='S'
)
ngoal = Node(
    goal[0],
    goal[1],
    goal[2],
    goal[3],
)


pq, g2minlist = [], {}
tmp_index = (int(nstart.xlist), int(nstart.ylist),
int(nstart.zlist//ZRESO), int(nstart.theta_xy_list/THETA_XY_RESOLUTION),
int(nstart.gradient_z_list/GRADIENT_Z_RESOLUTION))
tmp_f1, tmp_f2 = 100000000000, 100000000000
heapq.heappush(pq, (tmp_f1, tmp_f2, tmp_index, nstart))
# minf_solution is the minimum value of f2 in the Pareto front
num_iter, num_solution, num_contitue, minf_solution = 0, 0, 0, 100000000000
paro_h_x, paro_h_y = [], []
paro_nodes = []

start_time_3 = time.time()
while True:
    if not pq:
        print("Error: Cannot find path, No open set")
        break

    f1, f2, c_id, current = heapq.heappop(pq)
    num_iter += 1

    if num_iter % 50000 == 0:
        print(num_iter)

    x_to_e, y_to_e = abs(current.xlist - x_g), abs(current.ylist - y_g)
    if (x_to_e + y_to_e < 60) and ((current.line_type == "Z")):  # Preliminary determination of the distance to the endpoint to reduce computational effort
        cx, cy, cz, ctheta, cg = (current.xlist,current.ylist,current.zlist,current.theta_xy_list,current.gradient_z_list)
        dis_points = gtf.distance_point_to_point((cx, cy), (gx, gy))
        dis_p_to_l = gtf.distance_point_to_line((cx, cy, ctheta), (gx, gy))
        if ((dis_points <= 40) and (dis_p_to_l <= 2)):
            paro_h_x.append(current.f_cost), paro_h_y.append(current.f_carbon)
            paro_nodes.append(current)
            print('The number of routes in the current solution set is：', len(paro_nodes))
            if len(paro_h_x) > 100:
                break
            if minf_solution > f2:
                minf_solution = f2
            continue

    for neighbor in get_neighbors(current):
        neighbor_index = (int(neighbor.xlist), int(neighbor.ylist),
        int(neighbor.zlist//ZRESO), int(neighbor.theta_xy_list/THETA_XY_RESOLUTION),
        int(neighbor.gradient_z_list/GRADIENT_Z_RESOLUTION))
        tmp_f1, tmp_f2 = neighbor.f_cost, neighbor.f_carbon
        if neighbor_index not in g2minlist:
            g2minlist[neighbor_index] = 100000000000
        gdiff = neighbor.carbon - g2minlist[neighbor_index]
        if (gdiff >= 0) or (tmp_f2 >= minf_solution):
            num_contitue += 1
            continue
        if abs(gdiff) < 0.0001:
            continue
        g2minlist[neighbor_index] = neighbor.carbon
        heapq.heappush(pq, (tmp_f1, tmp_f2, neighbor_index, neighbor))
    current.pe = None  # Release memory
    current.house_set = None  # Release memory

print(num_iter)
# Output the alignment results to JSON
output_diction, filename = {}, 'Optimized_alignments-' + str(EXPLORE_RES*30) + ".json"
for i in range(len(paro_nodes)):
    tmp_node, alignment_num = paro_nodes[i], i+1
    [xs, ys, zs, ts, ss, bpd_lc, bpd_zs, pi_x, pi_y, pi_r] = reback(tmp_node, show_fig=False)
    alignment_info = {'x_cors': xs, 'y_cors': ys, 'design_eles': zs,
    'terrain_eles':ts, 'cors_mileages':ss, 'bpd_mileages':bpd_lc, 'bpd_eles':bpd_zs,
    'HPIx': pi_x, 'HPIy': pi_y, 'HR': pi_r}
    output_diction[alignment_num] = alignment_info
gtf.save_dict(output_diction, filename)